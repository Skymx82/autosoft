import { NextRequest, NextResponse } from 'next/server';
import Groq from 'groq-sdk';
import { supabase } from '@/lib/supabase';

// Initialiser le client Groq
const groq = new Groq({
  apiKey: process.env.GROQ_API_KEY,
});

export async function POST(request: NextRequest) {
  try {
    console.log('üöÄ D√©but de l\'API AI Insights');
    
    const body = await request.json();
    const { id_ecole, id_bureau } = body;
    console.log('üìä Param√®tres re√ßus:', { id_ecole, id_bureau });

    if (!id_ecole) {
      console.error('‚ùå ID √©cole manquant');
      return NextResponse.json(
        { error: 'ID √©cole requis' },
        { status: 400 }
      );
    }

    // V√©rifier que la cl√© API Groq est configur√©e
    if (!process.env.GROQ_API_KEY) {
      console.error('‚ùå Cl√© API Groq non configur√©e');
      return NextResponse.json(
        { error: 'Cl√© API Groq non configur√©e' },
        { status: 500 }
      );
    }
    console.log('‚úÖ Cl√© API Groq configur√©e');

    // 1. R√©cup√©rer les donn√©es de la base de donn√©es
    console.log('üì• R√©cup√©ration des donn√©es de Supabase...');

    // R√©cup√©ration de TOUTES les donn√©es pertinentes
    const { data: eleves, error: elevesError } = await supabase
      .from('eleves')
      .select('*')
      .eq('id_ecole', id_ecole);

    const { data: planning, error: planningError } = await supabase
      .from('planning')
      .select('*')
      .eq('id_ecole', id_ecole);

    const { data: enseignants, error: enseignantsError } = await supabase
      .from('enseignants')
      .select('*')
      .eq('id_ecole', id_ecole);

    const { data: vehicules, error: vehiculesError } = await supabase
      .from('vehicule')
      .select('*')
      .eq('id_ecole', id_ecole);

    const { data: recettes, error: recettesError } = await supabase
      .from('recette')
      .select('*')
      .eq('id_ecole', id_ecole);

    const { data: depenses, error: depensesError } = await supabase
      .from('depense')
      .select('*')
      .eq('id_ecole', id_ecole);

    const { data: examens, error: examensError } = await supabase
      .from('examen_resultats')
      .select('*')
      .eq('id_ecole', id_ecole);

    const { data: documents, error: documentsError } = await supabase
      .from('documents')
      .select('*')
      .eq('id_ecole', id_ecole);

    if (elevesError || planningError || enseignantsError || vehiculesError) {
      console.error('‚ùå Erreur Supabase:', { 
        elevesError, 
        planningError, 
        enseignantsError, 
        vehiculesError,
        recettesError,
        depensesError,
        examensError,
        documentsError
      });
      return NextResponse.json(
        { error: 'Erreur lors de la r√©cup√©ration des donn√©es' },
        { status: 500 }
      );
    }
    
    console.log('‚úÖ Donn√©es r√©cup√©r√©es:', {
      eleves: eleves?.length || 0,
      planning: planning?.length || 0,
      enseignants: enseignants?.length || 0,
      vehicules: vehicules?.length || 0,
      recettes: recettes?.length || 0,
      depenses: depenses?.length || 0,
      examens: examens?.length || 0,
      documents: documents?.length || 0
    });

    // 2. Pr√©parer un r√©sum√© COMPLET des donn√©es pour l'IA
    const now = new Date();
    const debutMois = new Date(now.getFullYear(), now.getMonth(), 1);
    const finMois = new Date(now.getFullYear(), now.getMonth() + 1, 0);
    
    const dataSummary = {
      // √âl√®ves
      total_eleves: eleves?.length || 0,
      eleves_actifs: eleves?.filter(e => e.statut_dossier === 'Actif').length || 0,
      eleves_archives: eleves?.filter(e => e.date_archivage).length || 0,
      
      // Enseignants
      total_enseignants: enseignants?.length || 0,
      
      // V√©hicules
      total_vehicules: vehicules?.length || 0,
      vehicules_actifs: vehicules?.filter(v => v.statut === 'Actif').length || 0,
      
      // Planning
      total_lecons: planning?.length || 0,
      lecons_ce_mois: planning?.filter(p => {
        const date = new Date(p.date);
        return date >= debutMois && date <= finMois;
      }).length || 0,
      lecons_prevues: planning?.filter(p => p.statut_lecon === 'Pr√©vue').length || 0,
      lecons_effectuees: planning?.filter(p => p.statut_lecon === 'Effectu√©e').length || 0,
      lecons_annulees: planning?.filter(p => p.statut_lecon === 'Annul√©e').length || 0,
      
      // Finances
      total_recettes: recettes?.reduce((sum, r) => sum + (parseFloat(r.montant_recette) || 0), 0) || 0,
      recettes_ce_mois: recettes?.filter(r => {
        const date = new Date(r.date_recette);
        return date >= debutMois && date <= finMois;
      }).reduce((sum, r) => sum + (parseFloat(r.montant_recette) || 0), 0) || 0,
      
      total_depenses: depenses?.reduce((sum, d) => sum + (parseFloat(d.montant_depense) || 0), 0) || 0,
      depenses_ce_mois: depenses?.filter(d => {
        const date = new Date(d.date_depense);
        return date >= debutMois && date <= finMois;
      }).reduce((sum, d) => sum + (parseFloat(d.montant_depense) || 0), 0) || 0,
      
      // Examens
      total_examens: examens?.length || 0,
      examens_reussis: examens?.filter(e => e.resultat === 'R√©ussi').length || 0,
      examens_echoues: examens?.filter(e => e.resultat === '√âchou√©').length || 0,
      taux_reussite: (examens && examens.length > 0)
        ? Math.round((examens.filter(e => e.resultat === 'R√©ussi').length / examens.length) * 100) 
        : 0,
      
      // Documents
      total_documents: documents?.length || 0,
      documents_valides: documents?.filter(d => d.etat === 'Valid√©').length || 0,
      documents_en_attente: documents?.filter(d => d.etat === 'En attente').length || 0,
    };

    // 3. Cr√©er le prompt pour l'IA avec TOUTES les donn√©es
    const prompt = `Tu es un analyste expert en gestion d'auto-√©cole. Voici les donn√©es COMPL√àTES d'une auto-√©cole :

**üìä √âl√®ves**
- Total : ${dataSummary.total_eleves}
- Actifs : ${dataSummary.eleves_actifs}
- Archiv√©s : ${dataSummary.eleves_archives}

**üë®‚Äçüè´ Enseignants**
- Total : ${dataSummary.total_enseignants}

**üöó V√©hicules**
- Total : ${dataSummary.total_vehicules}
- Actifs : ${dataSummary.vehicules_actifs}

**üìÖ Planning**
- Le√ßons totales : ${dataSummary.total_lecons}
- Le√ßons ce mois : ${dataSummary.lecons_ce_mois}
- Pr√©vues : ${dataSummary.lecons_prevues}
- Effectu√©es : ${dataSummary.lecons_effectuees}
- Annul√©es : ${dataSummary.lecons_annulees}

**üí∞ Finances**
- Recettes totales : ${dataSummary.total_recettes.toFixed(2)}‚Ç¨
- Recettes ce mois : ${dataSummary.recettes_ce_mois.toFixed(2)}‚Ç¨
- D√©penses totales : ${dataSummary.total_depenses.toFixed(2)}‚Ç¨
- D√©penses ce mois : ${dataSummary.depenses_ce_mois.toFixed(2)}‚Ç¨
- B√©n√©fice ce mois : ${(dataSummary.recettes_ce_mois - dataSummary.depenses_ce_mois).toFixed(2)}‚Ç¨

**üéì Examens**
- Total : ${dataSummary.total_examens}
- R√©ussis : ${dataSummary.examens_reussis}
- √âchou√©s : ${dataSummary.examens_echoues}
- Taux de r√©ussite : ${dataSummary.taux_reussite}%

**üìÑ Documents**
- Total : ${dataSummary.total_documents}
- Valid√©s : ${dataSummary.documents_valides}
- En attente : ${dataSummary.documents_en_attente}

**Ta mission :**
G√©n√®re EXACTEMENT 5 insights pertinents et actionnables pour cette auto-√©cole.

**Format de r√©ponse (STRICT) :**
R√©ponds UNIQUEMENT avec un tableau JSON valide, sans texte avant ou apr√®s. Chaque insight doit avoir ce format :

[
  {
    "type": "success" | "warning" | "info",
    "title": "Titre court (max 5 mots)",
    "description": "Description claire et actionnable (max 15 mots)",
    "value": "Valeur chiffr√©e (ex: +12%, 87%, 5)"
  }
]

**R√®gles importantes :**
- Utilise "success" pour les bonnes nouvelles
- Utilise "warning" pour les alertes
- Utilise "info" pour les informations neutres
- Les valeurs doivent √™tre des chiffres r√©els bas√©s sur les donn√©es
- Sois pr√©cis et actionnable
- Pas de texte en dehors du JSON

G√©n√®re maintenant les 5 insights :`;

    // 4. Appeler l'IA Groq
    console.log('ü§ñ Appel √† l\'IA Groq...');
    console.log('üìù R√©sum√© des donn√©es envoy√©es:', dataSummary);
    
    const completion = await groq.chat.completions.create({
      model: 'llama-3.3-70b-versatile',
      messages: [
        {
          role: 'system',
          content: 'Tu es un analyste expert en auto-√©cole. Tu r√©ponds UNIQUEMENT en JSON valide, sans texte suppl√©mentaire.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.7,
      max_completion_tokens: 1000,
      top_p: 1,
      stream: false,
    });

    const aiResponse = completion.choices[0]?.message?.content || '[]';
    console.log('‚úÖ R√©ponse IA re√ßue:', aiResponse);

    // 5. Parser la r√©ponse JSON
    let insights;
    try {
      console.log('üîÑ Nettoyage de la r√©ponse IA...');
      // Nettoyer la r√©ponse (enlever les backticks markdown si pr√©sents)
      const cleanedResponse = aiResponse
        .replace(/```json\n?/g, '')
        .replace(/```\n?/g, '')
        .trim();
      
      console.log('üìÑ R√©ponse nettoy√©e:', cleanedResponse);
      insights = JSON.parse(cleanedResponse);
      console.log('‚úÖ JSON pars√© avec succ√®s:', insights);
    } catch (parseError) {
      console.error('‚ùå Erreur de parsing JSON:', parseError);
      console.error('üìÑ R√©ponse brute:', aiResponse);
      // Fallback : insights par d√©faut
      insights = [
        {
          type: 'info',
          title: 'Analyse en cours',
          description: 'Les donn√©es sont en cours d\'analyse.',
          value: `${dataSummary.total_eleves}`
        },
        {
          type: 'success',
          title: 'Auto-√©cole active',
          description: `${dataSummary.total_moniteurs} moniteurs et ${dataSummary.total_vehicules} v√©hicules disponibles.`,
          value: `${dataSummary.lecons_ce_mois}`
        }
      ];
    }

    // 6. Ajouter des IDs aux insights
    const insightsWithIds = insights.map((insight: any, index: number) => ({
      id: index + 1,
      ...insight
    }));

    console.log('üéâ Insights finaux:', insightsWithIds);
    console.log('‚úÖ API termin√©e avec succ√®s');

    return NextResponse.json({
      insights: insightsWithIds,
      success: true
    });

  } catch (error: any) {
    console.error('‚ùå‚ùå‚ùå ERREUR CRITIQUE:', error);
    console.error('Stack trace:', error?.stack);
    
    return NextResponse.json(
      { 
        error: 'Erreur lors de la g√©n√©ration des insights',
        details: error?.message || 'Erreur inconnue'
      },
      { status: 500 }
    );
  }
}
